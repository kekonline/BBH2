Absolutely! Here's an improved and clearer version of your notes, tailored for bug bounty hunting with GraphQL. I've preserved **all original content** but enhanced structure, clarity, and readability, and added **inline usage examples** where helpful.

---

## ğŸ•µï¸â€â™‚ï¸ Bug Bounty Hunter Notes: GraphQL

---

### ğŸ” Universal Queries

To verify whether a URL corresponds to a GraphQL endpoint, you can use the **universal query**:

```graphql
query {
  __typename
}
```

This works because every GraphQL endpoint has a reserved field `__typename`, which returns the queried objectâ€™s type as a string.

ğŸ“¥ **Expected Response**:
```json
{
  "data": {
    "__typename": "Query"
  }
}
```

âœ… **Useful for probing common GraphQL endpoint paths**, such as:
- `/graphql`
- `/api`
- `/api/graphql`
- `/graphql/api`
- `/graphql/graphql`

---

### ğŸ“¦ Example: Product Query and Data Inference

```graphql
query {
  products {
    id
    name
    listed
  }
}
```

ğŸ“¤ **Example Response**:
```json
{
  "data": {
    "products": [
      { "id": 1, "name": "Product 1", "listed": true },
      { "id": 2, "name": "Product 2", "listed": true },
      { "id": 4, "name": "Product 4", "listed": true }
    ]
  }
}
```

ğŸ” **Observations**:
- Product IDs are sequential.
- ID `3` is missing â†’ possibly delisted/unlisted.

You can test this by querying for the missing product explicitly:

```graphql
query {
  product(id: 3) {
    id
    name
    listed
  }
}
```

ğŸ“¤ **Response**:
```json
{
  "data": {
    "product": {
      "id": 3,
      "name": "Product 3",
      "listed": false
    }
  }
}
```

â¡ï¸ Reveals **hidden/unlisted** data not shown in the default list.

---

### ğŸ” Using Introspection

GraphQL supports **introspection** to explore the schema.

#### âœ… Probing for Introspection

A simple test to see if introspection is enabled:

```json
{
  "query": "{ __schema { queryType { name } } }"
}
```

ğŸ“¥ If successful, this returns:
```json
{
  "data": {
    "__schema": {
      "queryType": {
        "name": "Query"
      }
    }
  }
}
```

ğŸ› ï¸ **Tools like Burp Suite** can automatically detect this and flag "GraphQL introspection enabled."

---

### ğŸ“š Full Introspection Query

To get **all schema details**, run a complete introspection query:

```graphql
query IntrospectionQuery {
  __schema {
    queryType { name }
    mutationType { name }
    subscriptionType { name }
    types {
      ...FullType
    }
    directives {
      name
      description
      args { ...InputValue }
      # These may cause errors:
      onOperation
      onFragment
      onField
    }
  }
}

fragment FullType on __Type {
  kind
  name
  description
  fields(includeDeprecated: true) {
    name
    description
    args { ...InputValue }
    type { ...TypeRef }
    isDeprecated
    deprecationReason
  }
  inputFields { ...InputValue }
  interfaces { ...TypeRef }
  enumValues(includeDeprecated: true) {
    name
    description
    isDeprecated
    deprecationReason
  }
  possibleTypes { ...TypeRef }
}

fragment InputValue on __InputValue {
  name
  description
  type { ...TypeRef }
  defaultValue
}

fragment TypeRef on __Type {
  kind
  name
  ofType {
    kind
    name
    ofType {
      kind
      name
      ofType {
        kind
        name
      }
    }
  }
}
```

ğŸ“ **Note**: If the query fails, try **removing `onOperation`, `onFragment`, and `onField`**â€”these are often not supported.

---

### ğŸ¤– Suggestions as Schema Leaks

Even if introspection is disabled, **suggestion messages** may leak schema data.

ğŸ§  For example, a malformed query like:

```graphql
query {
  productInfo {
    id
  }
}
```

âŒ May respond with:

```json
{
  "errors": [
    {
      "message": "Cannot query field 'productInfo' on type 'Query'. Did you mean 'productInformation'?"
    }
  ]
}
```

ğŸ’¡ This helps identify **valid fields**.

---

### ğŸ§© Tools: Clairvoyance

[Clairvoyance](https://github.com/nikitastupin/clairvoyance) is a tool that uses suggestions to **brute-force GraphQL schemas**, even when introspection is disabled.

ğŸš« Apollo servers do **not allow disabling suggestions** directly. See related GitHub threads for unofficial workarounds.

ğŸ“Œ **Burp Scanner** also checks for suggestions and flags it as "GraphQL suggestions enabled."

---

### ğŸ•³ï¸ Bypassing GraphQL Introspection Defenses

If introspection is blocked by simple regex filtering, you may be able to **evade it using spacing, newlines, or encoding**.

For example, if the regex only blocks `__schema{`, this still works:

```json
{
  "query": "query{__schema\n{queryType{name}}}"
}
```

ğŸ§ª Also try:
- GET requests (introspection may only be blocked for POST)
- `Content-Type: application/x-www-form-urlencoded`

---

### ğŸŒ Example: GET Introspection Probe

Use a browser or curl for a quick GET test:

```
GET /graphql?query=query%7B__schema%0A%7BqueryType%7Bname%7D%7D%7D
```

âœ… This might bypass introspection blocks that are only set up for POST requests.

---

### ğŸ—ºï¸ Pro Tips

- Use **Burp** to automatically:
  - Detect introspection/suggestions
  - Save GraphQL queries to the site map
- Be methodical: combine introspection, suggestions, and endpoint enumeration for maximum coverage.

---

Let me know if you want a printable Markdown/PDF version of these notes or if you want to expand this into an actual bug bounty recon checklist.